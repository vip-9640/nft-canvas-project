var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/schema/lifecycle.ts
var lifecycle_exports = {};
__export(lifecycle_exports, {
  closeMessageSchema: () => closeMessageSchema,
  contentSchema: () => contentSchema,
  initRequestSchema: () => initRequestSchema,
  initResponseSchema: () => initResponseSchema,
  userSchema: () => userSchema
});
import * as zod2 from "zod";

// src/schema/base/lib.ts
import * as zod from "zod";
function createClientMessageSchema(type, payloadSchema) {
  if (!payloadSchema) {
    return zod.object({
      type: zod.literal(type)
    });
  }
  return zod.object({
    type: zod.literal(type),
    payload: payloadSchema
  });
}
function createHostMessageSchema(type, untrustedSchema) {
  if (!untrustedSchema) {
    return zod.object({
      type: zod.literal(type),
      trustedBytes: zod.string()
    });
  }
  return zod.object({
    type: zod.literal(type),
    untrusted: untrustedSchema,
    trustedBytes: zod.string()
  });
}
var createFailedResponsePayload = (reasons) => {
  return zod.object({
    success: zod.literal(false),
    errorReason: zod.enum(reasons),
    error: zod.string().optional()
  });
};
var parseBaseClientMessage = (message) => {
  const clientMessageSchema = zod.object({
    type: zod.custom(),
    payload: zod.any().optional()
  });
  const parsedMessage = clientMessageSchema.safeParse(message);
  if (!parsedMessage.success) {
    return void 0;
  }
  return parsedMessage.data;
};
var parseBaseHostMessage = (message) => {
  const hostMessageSchema = zod.object({
    type: zod.custom(),
    untrusted: zod.any().optional(),
    trustedBytes: zod.string(),
    zod: zod.custom()
  });
  const parsedMessage = hostMessageSchema.safeParse(message);
  if (!parsedMessage.success) {
    return void 0;
  }
  return parsedMessage.data;
};

// src/schema/lifecycle.ts
var userSchema = zod2.object({
  id: zod2.string(),
  username: zod2.string(),
  avatar: zod2.string().optional()
});
var contentSchema = zod2.object({
  id: zod2.string(),
  portalId: zod2.string(),
  portalName: zod2.string()
});
var initRequestSchema = createClientMessageSchema(
  "lifecycle:init-request",
  zod2.object({
    version: zod2.string()
  })
);
var initResponseSchema = createHostMessageSchema(
  "lifecycle:init-response",
  zod2.object({
    user: userSchema.optional(),
    content: contentSchema.optional()
  })
);
var closeMessageSchema = createHostMessageSchema("lifecycle:close");

// src/schema/user.ts
var user_exports = {};
__export(user_exports, {
  connectWalletRequestSchema: () => connectWalletRequestSchema,
  connectWalletResponseSchema: () => connectWalletResponseSchema,
  contentReactionResponseSchema: () => contentReactionResponseSchema,
  copyToClipboardRequestSchema: () => copyToClipboardRequestSchema,
  copyToClipboardResponseSchema: () => copyToClipboardResponseSchema,
  createPostRequestSchema: () => createPostRequestSchema,
  createPostResponseSchema: () => createPostResponseSchema,
  initialInteractionRequestSchema: () => initialInteractionRequestSchema,
  openLnkRequestSchema: () => openLnkRequestSchema,
  resizeRequestSchema: () => resizeRequestSchema,
  signAndSendTransactionRequestSchema: () => signAndSendTransactionRequestSchema,
  signAndSendTransactionResponseSchema: () => signAndSendTransactionResponseSchema,
  unsignedTransactionSchema: () => unsignedTransactionSchema
});
import * as zod3 from "zod";
var connectWalletRequestSchema = createClientMessageSchema(
  "user:connect-wallet-request",
  zod3.object({
    chainId: zod3.string()
  })
);
var initialInteractionRequestSchema = createClientMessageSchema(
  "user:initial-interaction-request"
);
var resizeRequestSchema = createClientMessageSchema(
  "user:resize-request",
  zod3.object({
    width: zod3.number(),
    height: zod3.number()
  })
);
var connectWalletResponseSchema = createHostMessageSchema(
  "user:connect-wallet-response",
  zod3.union([
    zod3.object({
      success: zod3.literal(true),
      address: zod3.string(),
      walletName: zod3.string(),
      walletIcon: zod3.string(),
      walletUrl: zod3.string(),
      walletSupportedTransactionVersions: zod3.custom().optional()
    }),
    createFailedResponsePayload(["user-cancelled", "error"])
  ])
);
var unsignedTransactionSchema = zod3.object({
  unsignedTx: zod3.string(),
  awaitCommitment: zod3.enum(["confirmed", "finalized", "none"]).optional()
});
var signAndSendTransactionRequestSchema = createClientMessageSchema(
  "user:sign-send-transaction-request",
  unsignedTransactionSchema.extend({
    chainId: zod3.string()
  })
);
var signAndSendTransactionResponseSchema = createHostMessageSchema(
  "user:sign-send-transaction-response",
  zod3.union([
    zod3.object({
      success: zod3.literal(true),
      signedTx: zod3.string()
    }),
    createFailedResponsePayload(["user-cancelled", "error"])
  ])
);
var openLnkRequestSchema = createClientMessageSchema(
  "user:open-link-request",
  zod3.object({
    url: zod3.string()
  })
);
var createPostRequestSchema = createClientMessageSchema(
  "user:create-post-request",
  zod3.object({
    htmlContent: zod3.string()
  })
);
var createPostResponseSchema = createHostMessageSchema(
  "user:create-post-response",
  zod3.union([
    zod3.object({
      success: zod3.literal(true),
      contentId: zod3.bigint()
    }),
    createFailedResponsePayload(["user-cancelled", "error"])
  ])
);
var copyToClipboardRequestSchema = createClientMessageSchema(
  "user:copy-to-clipboard-request",
  zod3.object({
    content: zod3.string()
  })
);
var copyToClipboardResponseSchema = createHostMessageSchema(
  "user:copy-to-clipboard-response",
  zod3.union([
    zod3.object({
      success: zod3.literal(true)
    }),
    createFailedResponsePayload(["user-cancelled", "error"])
  ])
);
var contentReactionResponseSchema = createHostMessageSchema(
  "user:content-reaction-response",
  zod3.union([
    zod3.object({
      status: zod3.literal("reacted"),
      reaction: zod3.string()
    }),
    zod3.object({
      status: zod3.literal("cleared")
    })
  ])
);

// src/schema/core.ts
import * as zod4 from "zod";
var coreClientSchemas = [
  initRequestSchema,
  initialInteractionRequestSchema,
  resizeRequestSchema,
  connectWalletRequestSchema,
  signAndSendTransactionRequestSchema,
  openLnkRequestSchema,
  createPostRequestSchema,
  copyToClipboardRequestSchema
];
var coreHostSchemas = [
  initResponseSchema,
  closeMessageSchema,
  connectWalletResponseSchema,
  signAndSendTransactionResponseSchema,
  createPostResponseSchema,
  copyToClipboardResponseSchema,
  contentReactionResponseSchema
];
var parseCoreClientMessage = (message) => {
  const schema = zod4.union(coreClientSchemas);
  const parsedMessage = schema.safeParse(message);
  if (!parsedMessage.success) {
    return void 0;
  }
  return parsedMessage.data;
};
var parseCoreHostMessage = (message) => {
  const schema = zod4.union(coreHostSchemas);
  const parsedMessage = schema.safeParse(message);
  if (!parsedMessage.success) {
    return void 0;
  }
  return parsedMessage.data;
};

// src/errors.ts
var ClientAlreadyInitializedError = class extends Error {
  name = "ClientAlreadyInitializedError";
  message = "Client is already initialized";
};
var ClientNotInitializedError = class extends Error {
  name = "ClientNotInitializedError";
  message = "Client is not yet initialized";
};
var WindowNotDefinedError = class extends Error {
  name = "WindowNotDefinedError";
  message = "Window is not defined";
};
var ReferrerNotDefinedError = class extends Error {
  name = "ReferrerNotDefinedError";
  message = "Referrer is not defined";
};

// src/index.ts
var VERSION = "vNext";
export {
  ClientAlreadyInitializedError,
  ClientNotInitializedError,
  lifecycle_exports as Lifecycle,
  ReferrerNotDefinedError,
  user_exports as User,
  VERSION,
  WindowNotDefinedError,
  createClientMessageSchema,
  createFailedResponsePayload,
  createHostMessageSchema,
  parseBaseClientMessage,
  parseBaseHostMessage,
  parseCoreClientMessage,
  parseCoreHostMessage
};
//# sourceMappingURL=index.js.map