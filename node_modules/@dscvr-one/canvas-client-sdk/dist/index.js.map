{"version":3,"sources":["../src/index.ts","../src/client.ts","../src/context.ts"],"sourcesContent":["export * as CanvasInterface from '@dscvr-one/canvas-interface';\nexport { CanvasClient } from './client';\nexport { isIframeContext } from './context';\n","import EventEmitter from 'eventemitter3';\nimport * as CanvasInterface from '@dscvr-one/canvas-interface';\n\nexport class CanvasClient {\n  private sourceOrigin: string;\n  private initialized = false;\n  private initResponse: CanvasInterface.Lifecycle.InitResponse | undefined =\n    undefined;\n  private initialInteractionRegistered = false;\n  private eventBus = new EventEmitter<\n    string,\n    CanvasInterface.BaseHostMessage\n  >();\n\n  constructor() {\n    if (typeof window === 'undefined') {\n      throw new CanvasInterface.WindowNotDefinedError();\n    }\n\n    if (!document.referrer) {\n      throw new CanvasInterface.ReferrerNotDefinedError();\n    }\n    this.sourceOrigin = document.referrer;\n  }\n\n  destroy() {\n    this.initialized = false;\n    this.initResponse = undefined;\n    window.removeEventListener('message', this.handleReceiveMessage);\n    window.removeEventListener('click', this.handleInitialInteraction);\n    window.removeEventListener('focus', this.handleInitialInteraction);\n    this.removeInitialInteractionListeners();\n  }\n\n  get isReady() {\n    return !!this.initResponse;\n  }\n\n  async ready(onClose?: () => void) {\n    if (onClose) {\n      this.eventBus.on('lifecycle:close', onClose);\n    }\n    if (this.initResponse) {\n      return this.initResponse;\n    } else {\n      if (!this.initialized) {\n        window.addEventListener('message', this.handleReceiveMessage);\n        window.addEventListener('click', this.handleInitialInteraction);\n        window.addEventListener('focus', this.handleInitialInteraction);\n        this.sendHandshake();\n        this.initialized = true;\n      }\n      return await this.subscribeOnce(\n        CanvasInterface.Lifecycle.initResponseSchema,\n      );\n    }\n  }\n\n  subscribe<S extends CanvasInterface.BaseHostMessageSchema>(\n    schema: S,\n    callback: (message: CanvasInterface.BaseHostMessage<S>) => void,\n  ) {\n    const responseType = schema.shape.type.value;\n    this.eventBus.on(\n      responseType,\n      (message: CanvasInterface.BaseHostMessage<S>) => {\n        const parsedMessage = schema.safeParse(message);\n        if (!parsedMessage.success) {\n          return;\n        }\n        callback(message);\n      },\n    );\n  }\n\n  subscribeOnce<S extends CanvasInterface.BaseHostMessageSchema>(\n    schema: S,\n  ): Promise<CanvasInterface.BaseHostMessage<S>> {\n    const responseType = schema.shape.type.value;\n    return new Promise<CanvasInterface.BaseHostMessage<S>>((resolve) => {\n      this.eventBus.once(\n        responseType,\n        (message: CanvasInterface.BaseHostMessage<S>) => {\n          const parsedMessage = schema.safeParse(message);\n          if (!parsedMessage.success) {\n            return;\n          }\n          resolve(message);\n        },\n      );\n    });\n  }\n\n  sendMessage(message: CanvasInterface.BaseClientMessage) {\n    window.parent.postMessage(message, this.sourceOrigin);\n  }\n\n  sendMessageAndWaitResponse<\n    T extends CanvasInterface.BaseClientMessage,\n    S extends CanvasInterface.BaseHostMessageSchema,\n  >(\n    message: T,\n    responseSchema: S,\n  ): Promise<CanvasInterface.BaseHostMessage<S>> {\n    const responsePromise = this.subscribeOnce<S>(responseSchema);\n    this.sendMessage(message);\n    return responsePromise;\n  }\n\n  openLink(url: string) {\n    this.sendMessage({\n      type: 'user:open-link-request',\n      payload: {\n        url,\n      },\n    });\n  }\n\n  resize(newPayload?: CanvasInterface.User.ResizeRequest['payload']) {\n    const payload = newPayload ?? this.getWindowSize();\n    if (payload.width <= 0 || payload.height <= 0) {\n      return;\n    }\n    this.sendMessage({\n      type: 'user:resize-request',\n      payload,\n    });\n  }\n\n  createPost(\n    htmlContent: string,\n  ): Promise<CanvasInterface.User.CreatePostResponse> {\n    return this.sendMessageAndWaitResponse(\n      {\n        type: 'user:create-post-request',\n        payload: {\n          htmlContent,\n        },\n      },\n      CanvasInterface.User.createPostResponseSchema,\n    );\n  }\n\n  copyToClipboard(\n    content: string,\n  ): Promise<CanvasInterface.User.CopyToClipboardResponse> {\n    return this.sendMessageAndWaitResponse(\n      {\n        type: 'user:copy-to-clipboard-request',\n        payload: {\n          content,\n        },\n      },\n      CanvasInterface.User.copyToClipboardResponseSchema,\n    );\n  }\n\n  onContentReaction(\n    callback: (reaction: CanvasInterface.User.ContentReactionResponse) => void,\n  ) {\n    this.subscribe(\n      CanvasInterface.User.contentReactionResponseSchema,\n      callback,\n    );\n  }\n\n  connectWallet(\n    chainId: string,\n  ): Promise<CanvasInterface.User.ConnectWalletResponse> {\n    return this.sendMessageAndWaitResponse(\n      {\n        type: 'user:connect-wallet-request',\n        payload: {\n          chainId,\n        },\n      },\n      CanvasInterface.User.connectWalletResponseSchema,\n    );\n  }\n\n  signAndSendTransaction(\n    payload: CanvasInterface.User.UnsignedTransaction & {\n      chainId: string;\n    },\n  ) {\n    return this.sendMessageAndWaitResponse(\n      {\n        type: 'user:sign-send-transaction-request',\n        payload,\n      },\n      CanvasInterface.User.signAndSendTransactionResponseSchema,\n    );\n  }\n\n  async connectWalletAndSendTransaction(\n    chainId: string,\n    createTx: (\n      connectResponse: CanvasInterface.User.ConnectWalletResponse,\n    ) => Promise<CanvasInterface.User.UnsignedTransaction | undefined>,\n  ): Promise<CanvasInterface.User.SignAndSendTransactionResponse | undefined> {\n    const walletResponse = await this.connectWallet(chainId);\n    if (!walletResponse.untrusted.success) {\n      return {\n        ...walletResponse,\n        untrusted: {\n          ...walletResponse.untrusted,\n        },\n        type: 'user:sign-send-transaction-response',\n      };\n    }\n\n    const payload = await createTx(walletResponse);\n    if (!payload) {\n      return;\n    }\n    return await this.signAndSendTransaction({\n      chainId,\n      ...payload,\n    });\n  }\n\n  private sendHandshake() {\n    this.sendMessage({\n      type: 'lifecycle:init-request',\n      payload: {\n        version: CanvasInterface.VERSION,\n      },\n    });\n  }\n\n  private handleReceiveMessage = (\n    event: MessageEvent<CanvasInterface.BaseHostMessage>,\n  ) => {\n    const messageData = event.data;\n\n    const message = CanvasInterface.parseBaseHostMessage(messageData);\n    if (!message) {\n      return;\n    }\n\n    const parsedInitMessage =\n      CanvasInterface.Lifecycle.initResponseSchema.safeParse(messageData);\n    if (parsedInitMessage.success) {\n      if (this.initResponse) {\n        throw new CanvasInterface.ClientAlreadyInitializedError();\n      }\n      this.initResponse = parsedInitMessage.data;\n    } else if (!this.initResponse) {\n      throw new CanvasInterface.ClientNotInitializedError();\n    }\n\n    this.eventBus.emit(message.type, message);\n  };\n\n  private handleInitialInteraction = () => {\n    this.removeInitialInteractionListeners();\n    if (!this.initialInteractionRegistered) {\n      this.initialInteractionRegistered = true;\n      this.sendMessage({\n        type: 'user:initial-interaction-request',\n      });\n    }\n  };\n\n  private removeInitialInteractionListeners() {\n    window.removeEventListener('click', this.handleInitialInteraction);\n    window.removeEventListener('focus', this.handleInitialInteraction);\n  }\n\n  private getWindowSize() {\n    return {\n      width: window.document.body.clientWidth,\n      height: window.document.body.clientHeight,\n    };\n  }\n}\n","export const isIframeContext = () => {\n  try {\n    return window.self !== window.top;\n  } catch (e) {\n    return true;\n  }\n};\n"],"mappings":"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","names":["CanvasInterface"]}